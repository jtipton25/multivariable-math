{
  "hash": "997d1a272de522aedaa879dc68a7d82f",
  "result": {
    "markdown": "\n<!-- ---  -->\n<!-- title: \"Multivariable Mathematics for Data Science\" -->\n<!-- author: \"John Tipton\" -->\n<!-- date: | -->\n<!--   | Created 1 January 2020 -->\n<!--   | Last updated 24 August, 2022 -->\n<!-- documentclass: book -->\n<!-- link-citations: yes -->\n<!-- bibliography: -->\n<!-- - book.bib -->\n<!-- - packages.bib -->\n<!-- site: bookdown::bookdown_site -->\n<!-- biblio-style: apalike -->\n<!-- description: This is a text for Multivariable Mathematics for Data Science.  -->\n<!--   This text is used at the University of Arkansas for the course DASC 2594  -->\n<!--   that exposes students to topics in linear algebra and vector calculus that -->\n<!--   are needed for success in data science. As such, a large focus of the text -->\n<!--   is on computation for these topics. -->\n<!-- --- -->\n\n# Preface\n\n\n\n\n\n\n\n\n\n\n\nThis book will introduce students to multivariable Calculus and linear algebra methods and techniques to be successful in data science, statistics, computer science, and other data-driven, computational disciplines. \n\nThe motiviation for this text is to provide both a theoretical understanding of important multivariable methods used in data science as well as giving a hands-on experience using software. Throughout this text, we assume the reader has a solid foundation in univariate calculus (typically two semesters) as well as familiarity with a scripting language (e.g., R or python).\n\n\n\n## Getting started in `R`\n\nTBD\n\n## Some videos that explain useful concepts of linear algebra\n\n- [3 Blue 1 Brown -- Essence of Linear Algebra](https://www.3blue1brown.com/lessons/eola-preview)\n\n- [3 Blue 1 Brown -- Vectors](https://www.3blue1brown.com/lessons/vectors)\n\n\n\n\n## Notation\n\nFor notation, we let lowercase Roman letters represent scalar numbers (e.g., n = 5, d = 7), lowercase bold letters represent vectors \n\n\n\n\n$$\n\\begin{aligned}\n\\textbf{x} = \\begin{pmatrix}  x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{pmatrix},\n\\end{aligned}\n$$\n\n\n\n\nwhere the elements $x_1, \\ldots, x_n$ are scalars written in lowercase Roman. Note that vectors are assumed to follow a vertical notation where the elements of the vector (the $x_i$s are stacked on top of one another) and the order matters. For example, the vector \n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{x} & = \\begin{pmatrix} 5 \\\\ 2 \\\\ 8 \\end{pmatrix}\n\\end{aligned}\n$$\n\n\n\n\nhas the first element $x_1 = 5$, second element $x_2 = 2$ and third element $x_3 = 8$. Note that the vector $\\begin{pmatrix}  5 \\\\ 2 \\\\ 8 \\end{pmatrix}$ is not the same as the vector $\\begin{pmatrix}  8 \\\\ 2 \\\\ 5 \\end{pmatrix}$ because the order of the elements matters.\n\nWe can also write the vector as  \n\n\n\n\n$$\n\\begin{aligned}\n\\textbf{x} = \\left(  x_1, x_2, \\ldots, x_n \\right)',\n\\end{aligned}\n$$\n\n\n\n\nwhere the $'$ symbol represents the transpose function. For our example matrix, we have $\\begin{pmatrix}  5 \\\\ 2 \\\\ 8 \\end{pmatrix}' = \\begin{pmatrix} 5 & 2 & 8 \\end{pmatrix}$ which is the original vector but arranged in a row rather than a column. Likewise, the transpose of a row vector $\\begin{pmatrix} 5 & 2 & 8 \\end{pmatrix}' = \\begin{pmatrix}  5 \\\\ 2 \\\\ 8 \\end{pmatrix}$ is a column vector. If $\\mathbf{x}$ is a column vector, we say that $\\mathbf{x}'$ is a row vector and if $\\mathbf{x}$ is a row vector, the $\\mathbf{x}'$ is a column vector. \n\n\nTo create a vector we can use the concatenate function `c()`. For example, the vector $\\mathbf{x} = \\begin{pmatrix}  5 \\\\ 2 \\\\ 8 \\end{pmatrix}$ can be created as the `R` object using\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(5, 2, 8)\n```\n:::\n\n\n\n\nwhere the `<-` assigns the values in the vector `c(5, 2, 8)` to the object named `x`. To print the values of `x`, we can use\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 2 8\n```\n:::\n:::\n\n\n\n\nwhich prints the elements of x. Notice that `R` prints the elements of $\\mathbf{x}$ in a row; however, $\\mathbf{x}$ is a column vector. This inconsistency is present to allow the output to be printed in a manner easier to read (more numbers fit on a row). If we put the column vector into a `data.frame`, then the vector will be presented as a column vector\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x\n1 5\n2 2\n3 8\n```\n:::\n:::\n\n\n\n\nOne can use the index operator $[\\ ]$ to select specific elements of the vector $\\mathbf{x}$. For example, the first element of $\\mathbf{x}$, $x_1$, is\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n\n\nand the third element of $\\mathbf{x}$, $x_3$, is\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\n\n\nThe transpose function `t()` turns a column vector into a row vector (or a row vector into a column vector). For example the transpose $\\mathbf{x}'$ of $\\mathbf{x}$ is \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntx <- t(x)\ntx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    2    8\n```\n:::\n:::\n\n\n\n\nwhere `tx` is `R` object storing the transpose of $\\mathbf{x}$ and is a row vector. The transpose of `tx`. Notice the indices on the output of the row vector `tx`. The index operator `[1, ]` selects the first row to `tx` and the index operator `[, 1]` gives the first column `tx`. Taking the transpose again gives us back the original column vector\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(tx)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    5\n[2,]    2\n[3,]    8\n```\n:::\n:::\n\n\n\n\n### Matrices\n\nWe let uppercase bold letters $\\mathbf{A}$, $\\mathbf{B}$, etc., represent matrices. We define the matrix $\\mathbf{A}$ with $m$ rows and $n$ columns as\n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{A} & = \\begin{pmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn}\n\\end{pmatrix},\n\\end{aligned}\n$$\n\n\n\n\nwith $a_{ij}$ being the value of the matrix $\\mathbf{A}$ in the $i$th row and the $j$th column.\n\nIf the matrix \n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{A} & = \\begin{pmatrix} 5 & 7 & 1 \\\\\n5 & -22  & 2 \\\\\n-14 & 5 & 99 \\\\\n42 & -3 & 0\\end{pmatrix},\n\\end{aligned}\n$$\n\n\n\n\nthe elements $a_{11}$ = 5, $a_{12}$ = 7, $a_{21}$ = 5, and $a_{33}$ = 99, etc. \n\nIn `R`, we can define the matrix A using the `matrix()` function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(\n    data = c(5, 5, -14, 42, 7, -22, 5, -3, 1, 2, 99, 0),\n    nrow = 4,\n    ncol = 3\n)\n\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    7    1\n[2,]    5  -22    2\n[3,]  -14    5   99\n[4,]   42   -3    0\n```\n:::\n:::\n\n\n\n\nNotice in the above creation of $\\mathbf{A}$, we wrote defined the elements of the  $\\mathbf{A}$ using the columns stacked on top of one another. If we want to fill in the elements of $\\mathbf{A}$ using the rows, we can add the option `byrow = TRUE` to the `matrix()` function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(\n    data  = c(5, 7, 1, 5, -22, 2, -14, 5, 99, 42, -3, 0), \n    nrow  = 4,\n    ncol  = 3,\n    byrow = TRUE\n)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    7    1\n[2,]    5  -22    2\n[3,]  -14    5   99\n[4,]   42   -3    0\n```\n:::\n:::\n\n\n\n\nTo select the $ij$th elements of $\\mathbf{A}$, we use the subset operator `[` to select the element. For example, to get the element $a_{11} = 5$ in the first row and first column of $\\mathbf{A}$, we use\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[1, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n\n\nThe element $a_{3, 3} = 99$ in the third row and third column can be selected using\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[3, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 99\n```\n:::\n:::\n\n\n\n\n\nThe matrix $\\mathbf{A}$ can also be represented as a set of either column vectors $\\{\\mathbf{c}_j \\}_{j=1}^n$ or row vectors $\\{\\mathbf{r}_i \\}_{i=1}^m$. For example, the column vector representation is\n\n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{A} & = \\left( \\mathbf{c}_{1} \\middle| \\mathbf{c}_{2} \\middle| \\cdots \\middle| \\mathbf{c}_{n} \\right),\n\\end{aligned}\n$$\n\n\n\n\nwhere the notation $|$ is used to separate the vectors\n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{c}_1 & = \\begin{pmatrix} a_{11} \\\\ a_{21} \\\\ \\vdots \\\\ a_{m1}\n\\end{pmatrix},\n& \\mathbf{c}_2 & = \\begin{pmatrix} a_{12} \\\\ a_{22} \\\\ \\vdots \\\\ a_{m2}\n\\end{pmatrix}, \n& \\cdots, &\n& \\mathbf{c}_n & = \\begin{pmatrix} a_{n1} \\\\ a_{n2} \\\\ \\vdots \\\\ a_{nm}\n\\end{pmatrix}\n\\end{aligned}\n$$\n\n\n\n\nIn `R` you can extract the columns using the `[` selection operator\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc1 <- A[, 1] # first column\nc2 <- A[, 2] # second column\nc3 <- A[, 3] # third column\n```\n:::\n\n\n\n\nand you can give the column representation of the matrix `A` with with column bind function `cbind()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(c1, c2, c3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      c1  c2 c3\n[1,]   5   7  1\n[2,]   5 -22  2\n[3,] -14   5 99\n[4,]  42  -3  0\n```\n:::\n:::\n\n\n\n\nThe row vector representation of $\\mathbf{A}$ is \n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{A} & = \\begin{pmatrix} \\mathbf{r}_{1} \\\\ \\mathbf{r}_{2} \\\\ \\vdots \\\\ \\mathbf{r}_{m} \\end{pmatrix},\n\\end{aligned}\n$$\n\n\n\n\nwhere the row vectors $\\mathbf{r}_i$ are\n\n\n\n\n$$\n\\begin{aligned}\n\\mathbf{r}_1 & = \\left( a_{11}, a_{12}, \\ldots, a_{1n} \\right) \\\\\n\\mathbf{r}_2 & = \\left( a_{21}, a_{22}, \\ldots, a_{2n} \\right) \\\\\n& \\vdots \\\\\n\\mathbf{r}_m & = \\left( a_{m1}, a_{m2}, \\ldots, a_{mn} \\right)\n\\end{aligned}\n$$\n\n\n\n\n\nIn `R` you can extract the rows using the `[` selection operator\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr1 <- A[1, ] # first row\nr2 <- A[2, ] # second row\nr3 <- A[3, ] # third row\nr4 <- A[4, ] # fourth row\n```\n:::\n\n\n\n\nand you can give the row representation of the matrix `A` with with row bind function `rbind()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(r1, r2, r3, r4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3]\nr1    5    7    1\nr2    5  -22    2\nr3  -14    5   99\nr4   42   -3    0\n```\n:::\n:::\n\n\n\n\n\n\n\n<!-- ## Outline -->\n\n<!-- **Note: This is going to be revised and reformated throughout the class** -->\n\n<!-- 1) Introduction to vectors and matrices and vector and matrix operations -->\n\n<!-- 1) vector spaces and subspaces -->\n\n<!-- 2) dot products, cross products, projections -->\n\n<!-- 3) linear combinations, linear independence, bases, coordinate systems -->\n\n<!-- 4) planes, surfaces, and lines in space -->\n\n<!-- 5) linear transformations, matrix arithmetic, and matrix rank -->\n\n<!-- 6) solving linear equations $\\mathbf{A} \\mathbf{x} = \\mathbf{b}$ -->\n\n<!-- 7) innner products, outer products, and norms -->\n\n<!-- 8) projections - orthogonal projections and least squares -->\n\n<!-- 9) matrix decompositoins: Eigen, Cholesky, principal components,  -->\n<!-- singular value decomposition, pre-whitening -->\n\n<!-- 10) matrix decompositoins: Eigen, Cholesky, principal components,  -->\n<!-- singular value decomposition, pre-whitening -->\n\n<!-- 11) limits, continuity, and partial derivatives -->\n\n<!-- 12) chain rule, directional derivatives -->\n\n<!-- 13) tangent planes, linear approximations, Taylor Series -->\n\n<!-- 14) double/triple integrals, change of variables, Jacobian transformation -->\n\n<!-- 15) double/triple integrals, change of variables, Jacobian transformation -->\n\n\n\n\n\n\n\n\n\n\n\n<!-- Notes for revision -->\n<!-- 1) Start with vector and matrix addition/multiplication properties. Show how to  -->\n<!-- 2) Introduce how to solve a matrix equation with `solve()`. Notice that sometimes this works and sometimes this fails. Maybe we can understand why -->\n<!-- 3) Introduce systems of equations and rref  -->\n<!-- 4) Show how Gaussian-Jordan elimination can solve these equations using augmented matrices -->\n<!-- 5) Introduce linear combinations, spans, linear independence -->\n<!-- 6) Show how the concepts in 5) determine if a solution exists (invertibility) -->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": {},
    "postProcess": true
  }
}